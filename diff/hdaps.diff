--- a/drivers/hwmon/hdaps.c	2006-01-01 00:00:00.000000000 +0000
+++ b/drivers/hwmon/hdaps.c	2006-01-01 00:00:00.000000000 +0000
@@ -33,74 +33,62 @@
 #include <linux/module.h>
 #include <linux/timer.h>
 #include <linux/dmi.h>
+#include <linux/tp_base.h>
+#include <linux/jiffies.h>
 #include <asm/io.h>
 
-#define HDAPS_LOW_PORT		0x1600	/* first port used by hdaps */
-#define HDAPS_NR_PORTS		0x30	/* number of ports: 0x1600 - 0x162f */
-
-#define HDAPS_PORT_STATE	0x1611	/* device state */
-#define HDAPS_PORT_YPOS		0x1612	/* y-axis position */
-#define	HDAPS_PORT_XPOS		0x1614	/* x-axis position */
-#define HDAPS_PORT_TEMP1	0x1616	/* device temperature, in celcius */
-#define HDAPS_PORT_YVAR		0x1617	/* y-axis variance (what is this?) */
-#define HDAPS_PORT_XVAR		0x1619	/* x-axis variance (what is this?) */
-#define HDAPS_PORT_TEMP2	0x161b	/* device temperature (again?) */
-#define HDAPS_PORT_UNKNOWN	0x161c	/* what is this? */
-#define HDAPS_PORT_KMACT	0x161d	/* keyboard or mouse activity */
-
-#define STATE_FRESH		0x50	/* accelerometer data is fresh */
+#define HDAPS_IDX_STATE		0x1	/* device state */
+#define HDAPS_IDX_YPOS		0x2	/* y-axis position */
+#define	HDAPS_IDX_XPOS		0x4	/* x-axis position */
+#define HDAPS_IDX_TEMP1		0x6	/* device temperature, in celcius */
+#define HDAPS_IDX_YVAR		0x7	/* y-axis variance (what is this?) */
+#define HDAPS_IDX_XVAR		0x9	/* x-axis variance (what is this?) */
+#define HDAPS_IDX_TEMP2		0xb	/* device temperature (again?) */
+#define HDAPS_IDX_UNKNOWN	0xc	/* what is this? */
+#define HDAPS_IDX_KMACT		0xd	/* keyboard or mouse activity */
 
 #define KEYBD_MASK		0x20	/* set if keyboard activity */
 #define MOUSE_MASK		0x40	/* set if mouse activity */
-#define KEYBD_ISSET(n)		(!! (n & KEYBD_MASK))	/* keyboard used? */
-#define MOUSE_ISSET(n)		(!! (n & MOUSE_MASK))	/* mouse used? */
 
-#define INIT_TIMEOUT_MSECS	4000	/* wait up to 4s for device init ... */
-#define INIT_WAIT_MSECS		200	/* ... in 200ms increments */
+#define STATE_HAVE_POS          0x01    /* have position data */
+#define STATE_HAVE_VAR          0x02    /* have position and variance data */
+
+#define READ_TIMEOUT_MSECS	100	/* wait this long for device read */
+#define RETRY_MSECS		3	/* retry delay */
 
 #define HDAPS_POLL_PERIOD	(HZ/20)	/* poll for input every 1/20s */
 #define HDAPS_INPUT_FUZZ	4	/* input event threshold */
 #define HDAPS_INPUT_FLAT	4
 
+#define KMACT_REMEMBER_PERIOD   (HDAPS_POLL_PERIOD*2) /* k/m persistance */
+
 static struct timer_list hdaps_timer;
 static struct platform_device *pdev;
 static struct input_dev *hdaps_idev;
 static unsigned int hdaps_invert;
-static u8 km_activity;
-static int rest_x;
-static int rest_y;
+static unsigned int hdaps_force;
+static int needs_calibration = 0;
 
-static DECLARE_MUTEX(hdaps_sem);
-
-/*
- * __get_latch - Get the value from a given port.  Callers must hold hdaps_sem.
- */
-static inline u8 __get_latch(u16 port)
-{
-	return inb(port) & 0xff;
-}
-
-/*
- * __check_latch - Check a port latch for a given value.  Returns zero if the
- * port contains the given value.  Callers must hold hdaps_sem.
- */
-static inline int __check_latch(u16 port, u8 val)
-{
-	if (__get_latch(port) == val)
-		return 0;
-	return -EINVAL;
-}
+/* Latest state read */
+static int pos_x, pos_y;   /* position */
+static int var_x, var_y;   /* variance (what is this?) */
+static int rest_x, rest_y; /* calibrated rest position */
+static u8 temp1, temp2;    /* temperatures */
+
+/* Last time we saw keyboard and mouse activity */
+u64 last_keyboard_jiffies = INITIAL_JIFFIES;
+u64 last_mouse_jiffies = INITIAL_JIFFIES;
 
 /*
- * __wait_latch - Wait up to 100us for a port latch to get a certain value,
- * returning zero if the value is obtained.  Callers must hold hdaps_sem.
+ * __wait_latch - Wait for a port latch to get a certain value,
+ * returning zero if the value is obtained. Callers must hold controller lock.
  */
 static int __wait_latch(u16 port, u8 val)
 {
 	unsigned int i;
 
-	for (i = 0; i < 20; i++) {
-		if (!__check_latch(port, val))
+	for (i = 0; i < 200; i++) {
+		if (inb(port)==val)
 			return 0;
 		udelay(5);
 	}
@@ -108,82 +96,63 @@ static int __wait_latch(u16 port, u8 val
 	return -EIO;
 }
 
-/*
- * __device_refresh - request a refresh from the accelerometer.  Does not wait
- * for refresh to complete.  Callers must hold hdaps_sem.
- */
-static void __device_refresh(void)
-{
-	udelay(200);
-	if (inb(0x1604) != STATE_FRESH) {
-		outb(0x11, 0x1610);
-		outb(0x01, 0x161f);
-	}
-}
 
-/*
- * __device_refresh_sync - request a synchronous refresh from the
- * accelerometer.  We wait for the refresh to complete.  Returns zero if
- * successful and nonzero on error.  Callers must hold hdaps_sem.
- */
-static int __device_refresh_sync(void)
-{
-	__device_refresh();
-	return __wait_latch(0x1604, STATE_FRESH);
-}
-
-/*
- * __device_complete - indicate to the accelerometer that we are done reading
- * data, and then initiate an async refresh.  Callers must hold hdaps_sem.
+/* hdaps_read_row - read a row of data from the controller.
+ * Also prefetches the next read, to reduce udelay busy-waiting.
+ * If fast, do one quick attempt without retries.
+ * Caller must hold controller lock.
  */
-static inline void __device_complete(void)
-{
-	inb(0x161f);
-	inb(0x1604);
-	__device_refresh();
+static int hdaps_read_row(int fast, u8* row) {
+	int ret;
+	if (fast)
+		ret = tp_controller_try_read_row(0x11, 0x01, row);
+	else
+		ret = tp_controller_read_row(0x11, 0x01, row);
+	tp_controller_prefetch_row(0x11, 0x01);
+	return ret;
 }
 
-/*
- * hdaps_readb_one - reads a byte from a single I/O port, placing the value in
- * the given pointer.  Returns zero on success or a negative error on failure.
- * Can sleep.
+/* __hdaps_update - read current state and update global state variables.
+ * Caller must hold controller lock. 
  */
-static int hdaps_readb_one(unsigned int port, u8 *val)
+static int __hdaps_update(int fast)
 {
+	u8 row[TP_CONTROLLER_ROW_LEN];
 	int ret;
 
-	down(&hdaps_sem);
-
-	/* do a sync refresh -- we need to be sure that we read fresh data */
-	ret = __device_refresh_sync();
+	ret = hdaps_read_row(fast, row);
 	if (ret)
-		goto out;
-
-	*val = inb(port);
-	__device_complete();
+		return ret;
 
-out:
-	up(&hdaps_sem);
-	return ret;
-}
+	if (row[HDAPS_IDX_STATE]>=STATE_HAVE_POS) {
+		pos_x = *(s16*)(row+HDAPS_IDX_XPOS) * (hdaps_invert?-1:1);
+		pos_y = *(s16*)(row+HDAPS_IDX_YPOS) * (hdaps_invert?-1:1);
+	} else
+		return -EBUSY;
+
+	/* Don't insist on a "variance" readout; it's useless anyway. */
+	if (row[HDAPS_IDX_STATE]>=STATE_HAVE_VAR) {
+		var_x = *(s16*)(row+HDAPS_IDX_XVAR) * (hdaps_invert?-1:1);
+		var_y = *(s16*)(row+HDAPS_IDX_YVAR) * (hdaps_invert?-1:1);
+	}
 
-/* __hdaps_read_pair - internal lockless helper for hdaps_read_pair(). */
-static int __hdaps_read_pair(unsigned int port1, unsigned int port2,
-			     int *x, int *y)
-{
-	/* do a sync refresh -- we need to be sure that we read fresh data */
-	if (__device_refresh_sync())
-		return -EIO;
-
-	*y = inw(port2);
-	*x = inw(port1);
-	km_activity = inb(HDAPS_PORT_KMACT);
-	__device_complete();
-
-	/* if hdaps_invert is set, negate the two values */
-	if (hdaps_invert) {
-		*x = -*x;
-		*y = -*y;
+	/* Keyboard and mouse activity status is cleared as soon as it's read,
+	 * so applications will eat each other's events. Thus we remember any
+	 * event for KMACT_REMEMBER_PERIOD jiffies.
+	 */
+	if (row[HDAPS_IDX_KMACT] & KEYBD_MASK)
+		last_keyboard_jiffies = get_jiffies_64();
+	if (row[HDAPS_IDX_KMACT] & MOUSE_MASK)
+		last_mouse_jiffies = get_jiffies_64();
+
+	/* Temperatures */
+	temp1 = row[HDAPS_IDX_TEMP1];
+	temp2 = row[HDAPS_IDX_TEMP2];
+
+	if (needs_calibration) {
+		rest_x = pos_x;
+		rest_y = pos_y;
+		needs_calibration = 0;
 	}
 
 	return 0;
@@ -192,16 +161,23 @@ static int __hdaps_read_pair(unsigned in
 /*
  * hdaps_read_pair - reads the values from a pair of ports, placing the values
  * in the given pointers.  Returns zero on success.  Can sleep.
+ * Retries until timeout if the accelerometer is not in ready status (common).
+ * Does internal locking.
  */
-static int hdaps_read_pair(unsigned int port1, unsigned int port2,
-			   int *val1, int *val2)
+static int hdaps_update(void)
 {
-	int ret;
-
-	down(&hdaps_sem);
-	ret = __hdaps_read_pair(port1, port2, val1, val2);
-	up(&hdaps_sem);
+	int total, ret;
+	for (total=READ_TIMEOUT_MSECS; total>0; total-=RETRY_MSECS) {
+		tp_controller_lock();
+		ret = __hdaps_update(0);
+		tp_controller_unlock();
 
+		if (!ret)
+			return 0;
+		if (ret != -EBUSY)
+			break;
+		msleep(RETRY_MSECS);
+	}
 	return ret;
 }
 
@@ -211,30 +187,30 @@ static int hdaps_read_pair(unsigned int 
  */
 static int hdaps_device_init(void)
 {
-	int total, ret = -ENXIO;
-
-	down(&hdaps_sem);
-
-	outb(0x13, 0x1610);
-	outb(0x01, 0x161f);
-	if (__wait_latch(0x161f, 0x00))
-		goto out;
-
-	/*
-	 * Most ThinkPads return 0x01.
-	 *
-	 * Others--namely the R50p, T41p, and T42p--return 0x03.  These laptops
-	 * have "inverted" axises.
-	 *
-	 * The 0x02 value occurs when the chip has been previously initialized.
-	 */
-	if (__check_latch(0x1611, 0x03) &&
-		     __check_latch(0x1611, 0x02) &&
-		     __check_latch(0x1611, 0x01))
+	int ret = -ENXIO;
+	u8 row[TP_CONTROLLER_ROW_LEN];
+	u8 status;
+
+	tp_controller_lock();
+
+	if (tp_controller_read_row(0x13, 0x01, row))
+		goto out;
+	if (row[0xf]!=0x00)
+		goto out;
+	status = row[1];	
+		
+	if (status != 0x04 && /* Semi-invertex axes (ThinkPad T60) */
+	    status != 0x03 && /* Invertex axes (ThinkPad R50p, T41p, R42p) */
+	    status != 0x02 && /* Chip already initialized */
+	    status != 0x01 )  /* Normal axes */
+	{ 
+		printk(KERN_ERR "hdaps: initial latch check bad (0x%02x).\n",
+		       status);
 		goto out;
+	}
 
 	printk(KERN_DEBUG "hdaps: initial latch check good (0x%02x).\n",
-	       __get_latch(0x1611));
+	       status);
 
 	outb(0x17, 0x1610);
 	outb(0x81, 0x1611);
@@ -259,27 +235,18 @@ static int hdaps_device_init(void)
 	outb(0x01, 0x161f);
 	if (__wait_latch(0x161f, 0x00))
 		goto out;
-	if (__device_refresh_sync())
-		goto out;
-	if (__wait_latch(0x1611, 0x00))
-		goto out;
-
-	/* we have done our dance, now let's wait for the applause */
-	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
-		int x, y;
-
-		/* a read of the device helps push it into action */
-		__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);
-		if (!__wait_latch(0x1611, 0x02)) {
-			ret = 0;
-			break;
-		}
+	tp_controller_invalidate();
+	udelay(200);
 
-		msleep(INIT_WAIT_MSECS);
-	}
+	/* Just prefetch instead of reading, to avoid ~1sec delay on load */
+	ret = tp_controller_prefetch_row(0x11, 0x01);
+	goto good;
 
 out:
-	up(&hdaps_sem);
+	printk(KERN_ERR "hdaps: init failed!\n");
+good:
+	tp_controller_invalidate();
+	tp_controller_unlock();
 	return ret;
 }
 
@@ -298,13 +265,25 @@ static int hdaps_probe(struct platform_d
 	return 0;
 }
 
+static int hdaps_suspend(struct platform_device *dev, pm_message_t state)
+{
+	/* Don't do mouse polls until resume re-initializes the sensor. */
+	del_timer_sync(&hdaps_timer);
+	return 0;
+}
+
 static int hdaps_resume(struct platform_device *dev)
 {
-	return hdaps_device_init();
+	int ret = hdaps_device_init();
+	if (ret)
+		return ret;
+	mod_timer(&hdaps_timer, jiffies + HDAPS_POLL_PERIOD);
+	return 0;
 }
 
 static struct platform_driver hdaps_driver = {
 	.probe = hdaps_probe,
+	.suspend = hdaps_suspend,
 	.resume = hdaps_resume,
 	.driver	= {
 		.name = "hdaps",
@@ -313,34 +292,42 @@ static struct platform_driver hdaps_driv
 };
 
 /*
- * hdaps_calibrate - Set our "resting" values.  Callers must hold hdaps_sem.
+ * hdaps_calibrate - Set our "resting" values.
+ * Does its own locking.
  */
 static void hdaps_calibrate(void)
 {
-	__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &rest_x, &rest_y);
+	needs_calibration = 1;
+	hdaps_update();
+	/* If that fails, the mousedev poll will take care of things later. */
 }
 
+/* Timer handler for updating the input device. Runs in softirq context,
+ * so avoid lenghty or blocking operations.
+ */
 static void hdaps_mousedev_poll(unsigned long unused)
 {
-	int x, y;
+	int ret;
 
 	/* Cannot sleep.  Try nonblockingly.  If we fail, try again later. */
-	if (down_trylock(&hdaps_sem)) {
-		mod_timer(&hdaps_timer,jiffies + HDAPS_POLL_PERIOD);
+	if (tp_controller_trylock())
+		goto keep_active;
+
+	ret = __hdaps_update(1); /* fast update, we're in softirq context */
+	tp_controller_unlock();
+	/* Any of "successful", "not yet ready" and "not prefetched"? */
+	if (ret!=0 && ret!=-EBUSY && ret!=-ENODATA) {
+		printk(KERN_ERR 
+		       "hdaps: poll failed, disabling mousedev updates\n");
 		return;
 	}
 
-	if (__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y))
-		goto out;
-
-	input_report_abs(hdaps_idev, ABS_X, x - rest_x);
-	input_report_abs(hdaps_idev, ABS_Y, y - rest_y);
-	input_sync(hdaps_idev);
-
+keep_active:
 	mod_timer(&hdaps_timer, jiffies + HDAPS_POLL_PERIOD);
-
-out:
-	up(&hdaps_sem);
+	/* Even if we failed now, pos_x,y may have been updated earlier: */
+	input_report_abs(hdaps_idev, ABS_X, pos_x - rest_x);
+	input_report_abs(hdaps_idev, ABS_Y, pos_y - rest_y);
+	input_sync(hdaps_idev);
 }
 
 
@@ -349,65 +336,55 @@ out:
 static ssize_t hdaps_position_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	int ret, x, y;
-
-	ret = hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);
+	int ret = hdaps_update();
 	if (ret)
 		return ret;
-
-	return sprintf(buf, "(%d,%d)\n", x, y);
+	return sprintf(buf, "(%d,%d)\n", pos_x, pos_y);
 }
 
 static ssize_t hdaps_variance_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	int ret, x, y;
-
-	ret = hdaps_read_pair(HDAPS_PORT_XVAR, HDAPS_PORT_YVAR, &x, &y);
+	int ret = hdaps_update();
 	if (ret)
 		return ret;
-
-	return sprintf(buf, "(%d,%d)\n", x, y);
+	return sprintf(buf, "(%d,%d)\n", var_x, var_y);
 }
 
 static ssize_t hdaps_temp1_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	u8 temp;
-	int ret;
-
-	ret = hdaps_readb_one(HDAPS_PORT_TEMP1, &temp);
-	if (ret < 0)
+	int ret = hdaps_update();
+	if (ret)
 		return ret;
-
-	return sprintf(buf, "%u\n", temp);
+	return sprintf(buf, "%u\n", temp1);
 }
 
 static ssize_t hdaps_temp2_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	u8 temp;
-	int ret;
-
-	ret = hdaps_readb_one(HDAPS_PORT_TEMP2, &temp);
-	if (ret < 0)
+	int ret = hdaps_update();
+	if (ret)
 		return ret;
-
-	return sprintf(buf, "%u\n", temp);
+	return sprintf(buf, "%u\n", temp2);
 }
 
 static ssize_t hdaps_keyboard_activity_show(struct device *dev,
 					    struct device_attribute *attr,
 					    char *buf)
 {
-	return sprintf(buf, "%u\n", KEYBD_ISSET(km_activity));
+	/* Time-insensitive, so hdaps_mousedev_poll ensure updates. */
+	return sprintf(buf, "%u\n", 
+	   get_jiffies_64() < last_keyboard_jiffies + KMACT_REMEMBER_PERIOD);
 }
 
 static ssize_t hdaps_mouse_activity_show(struct device *dev,
 					 struct device_attribute *attr,
 					 char *buf)
 {
-	return sprintf(buf, "%u\n", MOUSE_ISSET(km_activity));
+	/* Time-insensitive, so hdaps_mousedev_poll ensure updates. */
+	return sprintf(buf, "%u\n", 
+	   get_jiffies_64() < last_mouse_jiffies + KMACT_REMEMBER_PERIOD);
 }
 
 static ssize_t hdaps_calibrate_show(struct device *dev,
@@ -420,10 +397,7 @@ static ssize_t hdaps_calibrate_store(str
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
-	down(&hdaps_sem);
 	hdaps_calibrate();
-	up(&hdaps_sem);
-
 	return count;
 }
 
@@ -530,20 +504,18 @@ static int __init hdaps_init(void)
 		{ .ident = NULL }
 	};
 
-	if (!dmi_check_system(hdaps_whitelist)) {
+	if (!(dmi_check_system(hdaps_whitelist) || hdaps_force)) {
 		printk(KERN_WARNING "hdaps: supported laptop not found!\n");
 		ret = -ENXIO;
 		goto out;
 	}
 
-	if (!request_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS, "hdaps")) {
-		ret = -ENXIO;
-		goto out;
-	}
-
+	/* Init timer before platform_driver_register, in case of suspend */
+	init_timer(&hdaps_timer);
+	hdaps_timer.function = hdaps_mousedev_poll;
 	ret = platform_driver_register(&hdaps_driver);
 	if (ret)
-		goto out_region;
+		goto out;
 
 	pdev = platform_device_register_simple("hdaps", -1, NULL, 0);
 	if (IS_ERR(pdev)) {
@@ -561,8 +533,8 @@ static int __init hdaps_init(void)
 		goto out_group;
 	}
 
-	/* initial calibrate for the input device */
-	hdaps_calibrate();
+	/* calibration for the input device (deferred to avoid delay) */
+	needs_calibration = 1;
 
 	/* initialize the input class */
 	hdaps_idev->name = "hdaps";
@@ -575,11 +547,7 @@ static int __init hdaps_init(void)
 
 	input_register_device(hdaps_idev);
 
-	/* start up our timer for the input device */
-	init_timer(&hdaps_timer);
-	hdaps_timer.function = hdaps_mousedev_poll;
-	hdaps_timer.expires = jiffies + HDAPS_POLL_PERIOD;
-	add_timer(&hdaps_timer);
+	mod_timer(&hdaps_timer, jiffies + HDAPS_POLL_PERIOD);
 
 	printk(KERN_INFO "hdaps: driver successfully loaded.\n");
 	return 0;
@@ -590,8 +558,6 @@ out_device:
 	platform_device_unregister(pdev);
 out_driver:
 	platform_driver_unregister(&hdaps_driver);
-out_region:
-	release_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);
 out:
 	printk(KERN_WARNING "hdaps: driver init failed (ret=%d)!\n", ret);
 	return ret;
@@ -604,7 +570,6 @@ static void __exit hdaps_exit(void)
 	sysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);
 	platform_device_unregister(pdev);
 	platform_driver_unregister(&hdaps_driver);
-	release_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);
 
 	printk(KERN_INFO "hdaps: driver unloaded.\n");
 }
@@ -615,6 +580,9 @@ module_exit(hdaps_exit);
 module_param_named(invert, hdaps_invert, bool, 0);
 MODULE_PARM_DESC(invert, "invert data along each axis");
 
+module_param_named(force, hdaps_force, bool, 0);
+MODULE_PARM_DESC(force, "force loading on non whitelisted laptops");
+
 MODULE_AUTHOR("Robert Love");
 MODULE_DESCRIPTION("IBM Hard Drive Active Protection System (HDAPS) driver");
 MODULE_LICENSE("GPL v2");
