--- a/drivers/hwmon/hdaps.c	2006-01-01 00:00:00.000000000 +0000
+++ b/drivers/hwmon/hdaps.c	2006-01-01 00:00:00.000000000 +0000
@@ -33,253 +33,256 @@
 #include <linux/module.h>
 #include <linux/timer.h>
 #include <linux/dmi.h>
-#include <asm/io.h>
+#include <linux/tp_base.h>
+#include <linux/jiffies.h>
 
-#define HDAPS_LOW_PORT		0x1600	/* first port used by hdaps */
-#define HDAPS_NR_PORTS		0x30	/* number of ports: 0x1600 - 0x162f */
-
-#define HDAPS_PORT_STATE	0x1611	/* device state */
-#define HDAPS_PORT_YPOS		0x1612	/* y-axis position */
-#define	HDAPS_PORT_XPOS		0x1614	/* x-axis position */
-#define HDAPS_PORT_TEMP1	0x1616	/* device temperature, in celcius */
-#define HDAPS_PORT_YVAR		0x1617	/* y-axis variance (what is this?) */
-#define HDAPS_PORT_XVAR		0x1619	/* x-axis variance (what is this?) */
-#define HDAPS_PORT_TEMP2	0x161b	/* device temperature (again?) */
-#define HDAPS_PORT_UNKNOWN	0x161c	/* what is this? */
-#define HDAPS_PORT_KMACT	0x161d	/* keyboard or mouse activity */
-
-#define STATE_FRESH		0x50	/* accelerometer data is fresh */
+#define HDAPS_IDX_READOUTS	0x1	/* readouts included in this read */
+					/* First readout, if READOUTS>=1: */
+#define HDAPS_IDX_YPOS1		0x2	/*   y-axis position word */
+#define HDAPS_IDX_XPOS1		0x4	/*   x-axis position word */
+#define HDAPS_IDX_TEMP1		0x6	/*   device temperature in Celsius */
+					/* Second readout, if READOUTS>=2: */
+#define HDAPS_IDX_XPOS2		0x7	/*   y-axis position word */
+#define HDAPS_IDX_YPOS2		0x9	/*   x-axis pisition word */
+#define HDAPS_IDX_TEMP2		0xb	/*   device temperature in Celsius */
+#define HDAPS_IDX_QUEUED	0xc	/* Number of queued readouts left */
+#define HDAPS_IDX_KMACT		0xd	/* keyboard or mouse activity */
 
 #define KEYBD_MASK		0x20	/* set if keyboard activity */
 #define MOUSE_MASK		0x40	/* set if mouse activity */
-#define KEYBD_ISSET(n)		(!! (n & KEYBD_MASK))	/* keyboard used? */
-#define MOUSE_ISSET(n)		(!! (n & MOUSE_MASK))	/* mouse used? */
 
-#define INIT_TIMEOUT_MSECS	4000	/* wait up to 4s for device init ... */
-#define INIT_WAIT_MSECS		200	/* ... in 200ms increments */
+#define EC_POLL_HZ		200     /* EC accelerometer sampling rate */
+#define EC_FILTER_DEPTH 	2       /* EC running average filter depth */
+
+#define READ_TIMEOUT_MSECS	100	/* wait this long for device read */
+#define RETRY_MSECS		3	/* retry delay */
 
 #define HDAPS_POLL_PERIOD	(HZ/20)	/* poll for input every 1/20s */
 #define HDAPS_INPUT_FUZZ	4	/* input event threshold */
 #define HDAPS_INPUT_FLAT	4
 
+#define KMACT_REMEMBER_PERIOD   (HZ/10) /* k/m persistance */
+
 static struct timer_list hdaps_timer;
 static struct platform_device *pdev;
 static struct input_dev *hdaps_idev;
 static unsigned int hdaps_invert;
-static u8 km_activity;
-static int rest_x;
-static int rest_y;
-
-static DECLARE_MUTEX(hdaps_sem);
+static unsigned int hdaps_force;
+static int needs_calibration = 0;
 
-/*
- * __get_latch - Get the value from a given port.  Callers must hold hdaps_sem.
+/* Latest state read */
+static int pos_x, pos_y;   /* position */
+static u8 temperature;     /* temperature */
+static int rest_x, rest_y; /* calibrated rest position */
+
+/* Last time we saw keyboard and mouse activity */
+u64 last_keyboard_jiffies = INITIAL_JIFFIES;
+u64 last_mouse_jiffies = INITIAL_JIFFIES;
+
+/* hdaps_read_row - read a row of data from the controller.
+ * Also prefetches the next read, to reduce udelay busy-waiting.
+ * If fast, do one quick attempt without retries.
+ * Caller must hold controller lock.
  */
-static inline u8 __get_latch(u16 port)
-{
-	return inb(port) & 0xff;
-}
+static int hdaps_read_row(int fast, u8 *dataval) {
+	int ret;
+	struct tp_controller_row args, data;
 
-/*
- * __check_latch - Check a port latch for a given value.  Returns zero if the
- * port contains the given value.  Callers must hold hdaps_sem.
- */
-static inline int __check_latch(u16 port, u8 val)
-{
-	if (__get_latch(port) == val)
-		return 0;
-	return -EINVAL;
+	args.val[0x0] = 0x11;
+	args.mask = 0x0001;
+	data.mask = (1 << HDAPS_IDX_READOUTS) | (1 << HDAPS_IDX_KMACT) |
+	            (3 << HDAPS_IDX_YPOS1)    | (3 << HDAPS_IDX_XPOS1) |
+	            (1 << HDAPS_IDX_TEMP1);
+	if (fast)
+		ret = tp_controller_try_read_row(&args, &data);
+	else
+		ret = tp_controller_read_row(&args, &data);
+	memcpy(dataval, &data.val, TP_CONTROLLER_ROW_LEN);
+	tp_controller_prefetch_row(&args);
+	return ret;
 }
 
-/*
- * __wait_latch - Wait up to 100us for a port latch to get a certain value,
- * returning zero if the value is obtained.  Callers must hold hdaps_sem.
+/* __hdaps_update - read current state and update global state variables.
+ * Caller must hold controller lock. 
  */
-static int __wait_latch(u16 port, u8 val)
+static int __hdaps_update(int fast)
 {
-	unsigned int i;
+	u8 row[TP_CONTROLLER_ROW_LEN];
+	int ret;
 
-	for (i = 0; i < 20; i++) {
-		if (!__check_latch(port, val))
-			return 0;
-		udelay(5);
-	}
+	ret = hdaps_read_row(fast, row);
+	if (ret)
+		return ret;
 
-	return -EIO;
-}
+	if (row[HDAPS_IDX_READOUTS]<1)
+		return -EBUSY; /* no pending readout, try again later */
 
-/*
- * __device_refresh - request a refresh from the accelerometer.  Does not wait
- * for refresh to complete.  Callers must hold hdaps_sem.
- */
-static void __device_refresh(void)
-{
-	udelay(200);
-	if (inb(0x1604) != STATE_FRESH) {
-		outb(0x11, 0x1610);
-		outb(0x01, 0x161f);
+	pos_x = *(s16*)(row+HDAPS_IDX_XPOS1) * (hdaps_invert?-1:1);
+	pos_y = *(s16*)(row+HDAPS_IDX_YPOS1) * (hdaps_invert?-1:1);
+
+	/* Keyboard and mouse activity status is cleared as soon as it's read,
+	 * so applications will eat each other's events. Thus we remember any
+	 * event for KMACT_REMEMBER_PERIOD jiffies.
+	 */
+	if (row[HDAPS_IDX_KMACT] & KEYBD_MASK)
+		last_keyboard_jiffies = get_jiffies_64();
+	if (row[HDAPS_IDX_KMACT] & MOUSE_MASK)
+		last_mouse_jiffies = get_jiffies_64();
+
+	/* Temperatures */
+	temperature = row[HDAPS_IDX_TEMP1];
+
+	if (needs_calibration) {
+		rest_x = pos_x;
+		rest_y = pos_y;
+		needs_calibration = 0;
 	}
-}
 
-/*
- * __device_refresh_sync - request a synchronous refresh from the
- * accelerometer.  We wait for the refresh to complete.  Returns zero if
- * successful and nonzero on error.  Callers must hold hdaps_sem.
- */
-static int __device_refresh_sync(void)
-{
-	__device_refresh();
-	return __wait_latch(0x1604, STATE_FRESH);
+	return 0;
 }
 
 /*
- * __device_complete - indicate to the accelerometer that we are done reading
- * data, and then initiate an async refresh.  Callers must hold hdaps_sem.
+ * hdaps_read_pair - reads the values from a pair of ports, placing the values
+ * in the given pointers.  Returns zero on success.  Can sleep.
+ * Retries until timeout if the accelerometer is not in ready status (common).
+ * Does internal locking.
  */
-static inline void __device_complete(void)
+static int hdaps_update(void)
 {
-	inb(0x161f);
-	inb(0x1604);
-	__device_refresh();
+	int total, ret;
+	for (total=READ_TIMEOUT_MSECS; total>0; total-=RETRY_MSECS) {
+		ret = tp_controller_lock();
+		if (ret)
+			return ret;
+		ret = __hdaps_update(0);
+		tp_controller_unlock();
+
+		if (!ret)
+			return 0;
+		if (ret != -EBUSY)
+			break;
+		msleep(RETRY_MSECS);
+	}
+	return ret;
 }
 
 /*
- * hdaps_readb_one - reads a byte from a single I/O port, placing the value in
- * the given pointer.  Returns zero on success or a negative error on failure.
- * Can sleep.
+ * hdaps_set_power - enable or disable power to the accelerometer.
+ * Returns zero on success and negative error code on failure.  Can sleep.
  */
-static int hdaps_readb_one(unsigned int port, u8 *val)
-{
+static int hdaps_set_power(int on) {
 	int ret;
-
-	down(&hdaps_sem);
-
-	/* do a sync refresh -- we need to be sure that we read fresh data */
-	ret = __device_refresh_sync();
+	struct tp_controller_row args, data;
+	args.val[0x0] = 0x14;
+	args.val[0x1] = on ? 0x01 : 0x00;
+	args.mask = 0x0003;
+	data.mask = 0x8000;
+	ret = tp_controller_read_row(&args, &data);
 	if (ret)
-		goto out;
-
-	*val = inb(port);
-	__device_complete();
-
-out:
-	up(&hdaps_sem);
-	return ret;
-}
-
-/* __hdaps_read_pair - internal lockless helper for hdaps_read_pair(). */
-static int __hdaps_read_pair(unsigned int port1, unsigned int port2,
-			     int *x, int *y)
-{
-	/* do a sync refresh -- we need to be sure that we read fresh data */
-	if (__device_refresh_sync())
+		return ret;
+	if (data.val[0xF]!=0x00)
 		return -EIO;
-
-	*y = inw(port2);
-	*x = inw(port1);
-	km_activity = inb(HDAPS_PORT_KMACT);
-	__device_complete();
-
-	/* if hdaps_invert is set, negate the two values */
-	if (hdaps_invert) {
-		*x = -*x;
-		*y = -*y;
-	}
-
 	return 0;
 }
 
 /*
- * hdaps_read_pair - reads the values from a pair of ports, placing the values
- * in the given pointers.  Returns zero on success.  Can sleep.
+ * hdaps_set_ec_config - set accelerometer parameters.
+ * freq - embedded controller sampling rate
+ * depth - embedded controller running average filter depth
+ * Returns zero on success and negative error code on failure.  Can sleep.
  */
-static int hdaps_read_pair(unsigned int port1, unsigned int port2,
-			   int *val1, int *val2)
-{
+static int hdaps_set_ec_config(int freq, int depth) {
 	int ret;
-
-	down(&hdaps_sem);
-	ret = __hdaps_read_pair(port1, port2, val1, val2);
-	up(&hdaps_sem);
-
-	return ret;
+	struct tp_controller_row args, data;
+	args.val[0x0] = 0x10;
+	args.val[0x1] = (u8)freq;
+	args.val[0x2] = (u8)(freq>>8);
+	args.val[0x3] = depth;
+	args.mask = 0x000F;
+	data.mask = 0x8000;
+	ret = tp_controller_read_row(&args, &data);
+	if (ret)
+		return ret;
+	if (data.val[0xF]!=0x00)
+		return -EIO;
+	return 0;
 }
 
 /*
  * hdaps_device_init - initialize the accelerometer.  Returns zero on success
  * and negative error code on failure.  Can sleep.
  */
+#define BAD_INIT(msg) do { err_msg = msg; goto bad; } while (0)
 static int hdaps_device_init(void)
 {
-	int total, ret = -ENXIO;
-
-	down(&hdaps_sem);
+	int ret;
+	struct tp_controller_row args, data;
+	u8 status;
+	const char *err_msg = "";
 
-	outb(0x13, 0x1610);
-	outb(0x01, 0x161f);
-	if (__wait_latch(0x161f, 0x00))
-		goto out;
+	ret = tp_controller_lock();
+	if (ret)
+		return ret;
 
-	/*
-	 * Most ThinkPads return 0x01.
-	 *
-	 * Others--namely the R50p, T41p, and T42p--return 0x03.  These laptops
-	 * have "inverted" axises.
-	 *
-	 * The 0x02 value occurs when the chip has been previously initialized.
-	 */
-	if (__check_latch(0x1611, 0x03) &&
-		     __check_latch(0x1611, 0x02) &&
-		     __check_latch(0x1611, 0x01))
-		goto out;
+	args.val[0x0] = 0x13; /* Get accelerometer info */
+	args.mask=0x0001;
+	data.mask=0x8002;
+	if (tp_controller_read_row(&args, &data))
+		BAD_INIT("read1");
+	if (data.val[0xF]==0x80 || data.val[0x1]==0x00)
+		BAD_INIT("accelerometer not available");
+	if (data.val[0xF]!=0x00)
+		BAD_INIT("check1");
+	status = data.val[0x1];
+		
+	if (status != 0x01 && /* Normal axes (ThinkPad T43) */
+	    status != 0x02 && /* Already initialized */
+	    status != 0x03 && /* Invertex axes (ThinkPad R50p, T41p, R42p) */
+	    status != 0x04 && /* Swapped axes (ThinkPad T60) */
+	    status != 0x05 )  /* Inverted X axis (ThinkPad X60s) */
+	{ 
+		printk(KERN_ERR "hdaps: initial latch check bad (0x%02x).\n",
+		       status);
+		BAD_INIT("latch");
+	}
 
 	printk(KERN_DEBUG "hdaps: initial latch check good (0x%02x).\n",
-	       __get_latch(0x1611));
+	       status);
 
-	outb(0x17, 0x1610);
-	outb(0x81, 0x1611);
-	outb(0x01, 0x161f);
-	if (__wait_latch(0x161f, 0x00))
-		goto out;
-	if (__wait_latch(0x1611, 0x00))
-		goto out;
-	if (__wait_latch(0x1612, 0x60))
-		goto out;
-	if (__wait_latch(0x1613, 0x00))
-		goto out;
-	outb(0x14, 0x1610);
-	outb(0x01, 0x1611);
-	outb(0x01, 0x161f);
-	if (__wait_latch(0x161f, 0x00))
-		goto out;
-	outb(0x10, 0x1610);
-	outb(0xc8, 0x1611);
-	outb(0x00, 0x1612);
-	outb(0x02, 0x1613);
-	outb(0x01, 0x161f);
-	if (__wait_latch(0x161f, 0x00))
-		goto out;
-	if (__device_refresh_sync())
-		goto out;
-	if (__wait_latch(0x1611, 0x00))
-		goto out;
+	args.val[0x0] = 0x17; /* Function unknown */
+	args.val[0x1] = 0x81;
+	args.mask = 0x0003;
+	data.mask = 0x800E;
+	if (tp_controller_read_row(&args, &data))
+		BAD_INIT("read2");
+	if (data.val[0x1]!=0x00 ||
+	    data.val[0x2]!=0x60 ||
+	    data.val[0x3]!=0x00 ||
+	    data.val[0xF]!=0x00)
+		BAD_INIT("check2");
 
-	/* we have done our dance, now let's wait for the applause */
-	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
-		int x, y;
-
-		/* a read of the device helps push it into action */
-		__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);
-		if (!__wait_latch(0x1611, 0x02)) {
-			ret = 0;
-			break;
-		}
+	if (hdaps_set_power(1))
+		BAD_INIT("hdaps_set_power");
 
-		msleep(INIT_WAIT_MSECS);
-	}
+	if (hdaps_set_ec_config(EC_POLL_HZ, EC_FILTER_DEPTH))
+		BAD_INIT("hdaps_set_ec_config");
 
-out:
-	up(&hdaps_sem);
+	tp_controller_invalidate();
+	udelay(200);
+
+	/* Just prefetch instead of reading, to avoid ~1sec delay on load */
+	args.val[0x0] = 0x11;
+	args.mask = 0x0001;
+	ret = tp_controller_prefetch_row(&args);
+	if (ret)
+		BAD_INIT("prefetch");
+	goto good;
+bad:
+	ret = -ENXIO;
+	printk(KERN_ERR "hdaps: init failed (%s)\n", err_msg);
+good:
+	tp_controller_invalidate();
+	tp_controller_unlock();
 	return ret;
 }
 
@@ -298,13 +301,25 @@ static int hdaps_probe(struct platform_d
 	return 0;
 }
 
+static int hdaps_suspend(struct platform_device *dev, pm_message_t state)
+{
+	/* Don't do mouse polls until resume re-initializes the sensor. */
+	del_timer_sync(&hdaps_timer);
+	return 0;
+}
+
 static int hdaps_resume(struct platform_device *dev)
 {
-	return hdaps_device_init();
+	int ret = hdaps_device_init();
+	if (ret)
+		return ret;
+	mod_timer(&hdaps_timer, jiffies + HDAPS_POLL_PERIOD);
+	return 0;
 }
 
 static struct platform_driver hdaps_driver = {
 	.probe = hdaps_probe,
+	.suspend = hdaps_suspend,
 	.resume = hdaps_resume,
 	.driver	= {
 		.name = "hdaps",
@@ -313,34 +328,42 @@ static struct platform_driver hdaps_driv
 };
 
 /*
- * hdaps_calibrate - Set our "resting" values.  Callers must hold hdaps_sem.
+ * hdaps_calibrate - Set our "resting" values.
+ * Does its own locking.
  */
 static void hdaps_calibrate(void)
 {
-	__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &rest_x, &rest_y);
+	needs_calibration = 1;
+	hdaps_update();
+	/* If that fails, the mousedev poll will take care of things later. */
 }
 
+/* Timer handler for updating the input device. Runs in softirq context,
+ * so avoid lenghty or blocking operations.
+ */
 static void hdaps_mousedev_poll(unsigned long unused)
 {
-	int x, y;
+	int ret;
 
 	/* Cannot sleep.  Try nonblockingly.  If we fail, try again later. */
-	if (down_trylock(&hdaps_sem)) {
-		mod_timer(&hdaps_timer,jiffies + HDAPS_POLL_PERIOD);
+	if (tp_controller_try_lock())
+		goto keep_active;
+
+	ret = __hdaps_update(1); /* fast update, we're in softirq context */
+	tp_controller_unlock();
+	/* Any of "successful", "not yet ready" and "not prefetched"? */
+	if (ret!=0 && ret!=-EBUSY && ret!=-ENODATA) {
+		printk(KERN_ERR 
+		       "hdaps: poll failed, disabling mousedev updates\n");
 		return;
 	}
 
-	if (__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y))
-		goto out;
-
-	input_report_abs(hdaps_idev, ABS_X, x - rest_x);
-	input_report_abs(hdaps_idev, ABS_Y, y - rest_y);
+keep_active:
+	/* Even if we failed now, pos_x,y may have been updated earlier: */
+	input_report_abs(hdaps_idev, ABS_X, pos_x - rest_x);
+	input_report_abs(hdaps_idev, ABS_Y, pos_y - rest_y);
 	input_sync(hdaps_idev);
-
 	mod_timer(&hdaps_timer, jiffies + HDAPS_POLL_PERIOD);
-
-out:
-	up(&hdaps_sem);
 }
 
 
@@ -349,65 +372,37 @@ out:
 static ssize_t hdaps_position_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	int ret, x, y;
-
-	ret = hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);
-	if (ret)
-		return ret;
-
-	return sprintf(buf, "(%d,%d)\n", x, y);
-}
-
-static ssize_t hdaps_variance_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	int ret, x, y;
-
-	ret = hdaps_read_pair(HDAPS_PORT_XVAR, HDAPS_PORT_YVAR, &x, &y);
+	int ret = hdaps_update();
 	if (ret)
 		return ret;
-
-	return sprintf(buf, "(%d,%d)\n", x, y);
-}
-
-static ssize_t hdaps_temp1_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	u8 temp;
-	int ret;
-
-	ret = hdaps_readb_one(HDAPS_PORT_TEMP1, &temp);
-	if (ret < 0)
-		return ret;
-
-	return sprintf(buf, "%u\n", temp);
+	return sprintf(buf, "(%d,%d)\n", pos_x, pos_y);
 }
 
-static ssize_t hdaps_temp2_show(struct device *dev,
+static ssize_t hdaps_temperature_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	u8 temp;
-	int ret;
-
-	ret = hdaps_readb_one(HDAPS_PORT_TEMP2, &temp);
-	if (ret < 0)
+	int ret = hdaps_update();
+	if (ret)
 		return ret;
-
-	return sprintf(buf, "%u\n", temp);
+	return sprintf(buf, "%u\n", temperature);
 }
 
 static ssize_t hdaps_keyboard_activity_show(struct device *dev,
 					    struct device_attribute *attr,
 					    char *buf)
 {
-	return sprintf(buf, "%u\n", KEYBD_ISSET(km_activity));
+	/* Time-insensitive, so hdaps_mousedev_poll ensure updates. */
+	return sprintf(buf, "%u\n", 
+	   get_jiffies_64() < last_keyboard_jiffies + KMACT_REMEMBER_PERIOD);
 }
 
 static ssize_t hdaps_mouse_activity_show(struct device *dev,
 					 struct device_attribute *attr,
 					 char *buf)
 {
-	return sprintf(buf, "%u\n", MOUSE_ISSET(km_activity));
+	/* Time-insensitive, so hdaps_mousedev_poll ensure updates. */
+	return sprintf(buf, "%u\n", 
+	   get_jiffies_64() < last_mouse_jiffies + KMACT_REMEMBER_PERIOD);
 }
 
 static ssize_t hdaps_calibrate_show(struct device *dev,
@@ -420,10 +415,7 @@ static ssize_t hdaps_calibrate_store(str
 				     struct device_attribute *attr,
 				     const char *buf, size_t count)
 {
-	down(&hdaps_sem);
 	hdaps_calibrate();
-	up(&hdaps_sem);
-
 	return count;
 }
 
@@ -449,9 +441,8 @@ static ssize_t hdaps_invert_store(struct
 }
 
 static DEVICE_ATTR(position, 0444, hdaps_position_show, NULL);
-static DEVICE_ATTR(variance, 0444, hdaps_variance_show, NULL);
-static DEVICE_ATTR(temp1, 0444, hdaps_temp1_show, NULL);
-static DEVICE_ATTR(temp2, 0444, hdaps_temp2_show, NULL);
+static DEVICE_ATTR(temp1, 0444, hdaps_temperature_show, NULL); 
+  /* named temp1 instead of temperature for backward compatibility */
 static DEVICE_ATTR(keyboard_activity, 0444, hdaps_keyboard_activity_show, NULL);
 static DEVICE_ATTR(mouse_activity, 0444, hdaps_mouse_activity_show, NULL);
 static DEVICE_ATTR(calibrate, 0644, hdaps_calibrate_show,hdaps_calibrate_store);
@@ -459,9 +450,7 @@ static DEVICE_ATTR(invert, 0644, hdaps_i
 
 static struct attribute *hdaps_attributes[] = {
 	&dev_attr_position.attr,
-	&dev_attr_variance.attr,
 	&dev_attr_temp1.attr,
-	&dev_attr_temp2.attr,
 	&dev_attr_keyboard_activity.attr,
 	&dev_attr_mouse_activity.attr,
 	&dev_attr_calibrate.attr,
@@ -542,20 +531,18 @@ static int __init hdaps_init(void)
 		{ .ident = NULL }
 	};
 
-	if (!dmi_check_system(hdaps_whitelist)) {
+	if (!(dmi_check_system(hdaps_whitelist) || hdaps_force)) {
 		printk(KERN_WARNING "hdaps: supported laptop not found!\n");
 		ret = -ENODEV;
 		goto out;
 	}
 
-	if (!request_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS, "hdaps")) {
-		ret = -ENXIO;
-		goto out;
-	}
-
+	/* Init timer before platform_driver_register, in case of suspend */
+	init_timer(&hdaps_timer);
+	hdaps_timer.function = hdaps_mousedev_poll;
 	ret = platform_driver_register(&hdaps_driver);
 	if (ret)
-		goto out_region;
+		goto out;
 
 	pdev = platform_device_register_simple("hdaps", -1, NULL, 0);
 	if (IS_ERR(pdev)) {
@@ -573,8 +560,8 @@ static int __init hdaps_init(void)
 		goto out_group;
 	}
 
-	/* initial calibrate for the input device */
-	hdaps_calibrate();
+	/* calibration for the input device (deferred to avoid delay) */
+	needs_calibration = 1;
 
 	/* initialize the input class */
 	hdaps_idev->name = "hdaps";
@@ -587,11 +574,7 @@ static int __init hdaps_init(void)
 
 	input_register_device(hdaps_idev);
 
-	/* start up our timer for the input device */
-	init_timer(&hdaps_timer);
-	hdaps_timer.function = hdaps_mousedev_poll;
-	hdaps_timer.expires = jiffies + HDAPS_POLL_PERIOD;
-	add_timer(&hdaps_timer);
+	mod_timer(&hdaps_timer, jiffies + HDAPS_POLL_PERIOD);
 
 	printk(KERN_INFO "hdaps: driver successfully loaded.\n");
 	return 0;
@@ -602,8 +585,6 @@ out_device:
 	platform_device_unregister(pdev);
 out_driver:
 	platform_driver_unregister(&hdaps_driver);
-out_region:
-	release_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);
 out:
 	printk(KERN_WARNING "hdaps: driver init failed (ret=%d)!\n", ret);
 	return ret;
@@ -616,7 +597,6 @@ static void __exit hdaps_exit(void)
 	sysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);
 	platform_device_unregister(pdev);
 	platform_driver_unregister(&hdaps_driver);
-	release_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);
 
 	printk(KERN_INFO "hdaps: driver unloaded.\n");
 }
@@ -627,6 +607,9 @@ module_exit(hdaps_exit);
 module_param_named(invert, hdaps_invert, bool, 0);
 MODULE_PARM_DESC(invert, "invert data along each axis");
 
+module_param_named(force, hdaps_force, bool, 0);
+MODULE_PARM_DESC(force, "force loading on non whitelisted laptops");
+
 MODULE_AUTHOR("Robert Love");
 MODULE_DESCRIPTION("IBM Hard Drive Active Protection System (HDAPS) driver");
 MODULE_LICENSE("GPL v2");
